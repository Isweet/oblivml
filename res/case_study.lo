(* Types *)
type data0 = secret flip 0 * secret flip 0 in
type data1 = secret flip 1 * secret flip 1 in

type block01 =
  { isdummy : secret bit 0, 
    idx     : secret int 0, 
    pos     : secret bit 0,
    data    : data1
  }
in

type bucket01 = block01 array in

type noram01 = bucket01 array in

type block10 =
  { isdummy : secret bit 1, 
    idx     : secret int 1, 
    pos     : secret bit 1,
    data    : data0
  }
in

type bucket10 = block10 array in

type noram10 = bucket10 array in
(* Helpers *)

let rnd0 (ignore : unit) = toss secret 0 in

let rnd1 (ignore : unit) = toss secret 1 in

let bit_to_region0 (b : secret bit) =
  let dummy = rnd0 @ () in
  let (v, ignore) = mux universal (O secret, b, use(dummy)) in
  v
in

let bit_to_region1 (b : secret bit) =
  let dummy = rnd1 @ () in
  let (v, ignore) = mux universal (O secret, b, use(dummy)) in
  v
in

let int_to_region0 (n : secret int) =
  let dummy = rnd0 @ () in
  let (launder, ignore) = mux universal (use(dummy), 0 secret, 0 secret) in
  let (v, ignore) = mux universal (O secret, n, launder) in
  v
in

let int_to_region1 (n : secret int) =
  let dummy = rnd1 @ () in
  let (launder, ignore) = mux universal (use(dummy), 0 secret, 0 secret) in
  let (v, ignore) = mux universal (O secret, n, launder) in
  v
in

let dummy_block01 (ignore : unit) = 
  { isdummy -> bit_to_region0 @ I secret,
    idx     -> int_to_region0 @ 0 secret,
    pos     -> bit_to_region0 @ O secret,
    data    -> (rnd1 @ (), rnd1 @ ())
  }
in

let dummy_block10 (ignore : unit) = 
  { isdummy -> bit_to_region1 @ I secret,
    idx     -> int_to_region1 @ 0 secret,
    pos     -> bit_to_region1 @ O secret,
    data    -> (rnd0 @ (), rnd0 @ ())
  }
in

let rec pow2 (exp : public int) : public int =
  if exp = 0 public then
    1 public
  else
    2 public * pow2 @ (exp + -1 public)
in

(* NR Operations *)

let rr_bucket01 (bucket : bucket01) (idx : secret int 0) (read : block01) : block01 =
  let rec rr_bucket_h (i : public int) (read : block01) : block01 =
    if i = length(bucket) then
        read
    else
      let bl = bucket[i] <- dummy_block01 @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_bl) && idx_bl = idx in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_left_b, data_right_b) } in
      let _ = bucket[i] <- b in
      rr_bucket_h @ (i + 1 public) @ a
  in
  rr_bucket_h @ 0 public @ read
in

let rr_bucket10 (bucket : bucket10) (idx : secret int 1) (read : block10) : block10 =
  let rec rr_bucket_h (i : public int) (read : block10) : block10 =
    if i = length(bucket) then
        read
    else
      let bl = bucket[i] <- dummy_block10 @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_bl) && idx_bl = idx in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_left_b, data_right_b) } in
      let _ = bucket[i] <- b in
      rr_bucket_h @ (i + 1 public) @ a
  in
  rr_bucket_h @ 0 public @ read
in

let rr01 (oram : noram01) (idx : secret int 0) (tag : public bit) =
  let rec rr_h (level : public int) (read : block01) : block01 =
    let base = (pow2 @ level) + -1 public in
    if base = length(oram) then
      read
    else
      let bucket_index = base (* + (tag & base) *) in (* TODO: tag is a public bit so this type shouldn't change *)
      let bucket = oram[bucket_index] in
      let read = rr_bucket01 @ bucket @ idx @ read in
      rr_h @ (level + 1 public) @ read
  in
  let read = dummy_block01 @ () in
  let { isdummy -> ignore, idx -> ignore, pos -> ignore, data -> ret } = rr_h @ 0 public @ read in
  ret
in

let rr10 (oram : noram10) (idx : secret int 1) (tag : public bit) =
  let rec rr_h (level : public int) (read : block10) : block10 =
    let base = (pow2 @ level) + -1 public in
    if base = length(oram) then
      read
    else
      let bucket_index = base (* + (tag & base) *) in (* TODO: tag is a public bit so this type shouldn't change *)
      let bucket = oram[bucket_index] in
      let read = rr_bucket10 @ bucket @ idx @ read in
      rr_h @ (level + 1 public) @ read
  in
  let read = dummy_block10 @ () in
  let { isdummy -> ignore, idx -> ignore, pos -> ignore, data -> ret } = rr_h @ 0 public @ read in
  ret
in

let add_bucket01 (bucket : bucket01) (read : block01) : block01 =
  let rec add_bucket_h (i : public int) (read : block01) : block01 =
    if i = length(bucket) then
      read
    else
      let bl = bucket[i] <- dummy_block01 @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_r) && isdummy_bl in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_left_b, data_right_b) } in
      let _ = bucket[i] <- b in
      add_bucket_h @ (i + 1 public) @ a
  in
  add_bucket_h @ 0 public @ read
in

let add_bucket10 (bucket : bucket10) (read : block10) : block10 =
  let rec add_bucket_h (i : public int) (read : block10) : block10 =
    if i = length(bucket) then
      read
    else
      let bl = bucket[i] <- dummy_block10 @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_r) && isdummy_bl in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_left_b, data_right_b) } in
      let _ = bucket[i] <- b in
      add_bucket_h @ (i + 1 public) @ a
  in
  add_bucket_h @ 0 public @ read
in

let add01 (oram : noram01) (idx : secret int 0) (tag : secret bit 0) (data : data1) =
  let to_add = { isdummy -> bit_to_region0 @ O secret, idx -> idx, pos -> tag, data -> data } in
  let bucket = oram[0 public] in
  add_bucket01 @ bucket @ to_add
in

let add10 (oram : noram10) (idx : secret int 1) (tag : secret bit 1) (data : data0) =
  let to_add = { isdummy -> bit_to_region1 @ O secret, idx -> idx, pos -> tag, data -> data } in
  let bucket = oram[0 public] in
  add_bucket10 @ bucket @ to_add
in

(* More Types *)

type to_block =
  { isdummy : secret bit 0,
    idx     : secret int 0,
    data    : data1
  }
in

type trivial_oram = to_block array in

type oram = (noram01 * noram10) array * trivial_oram in

(* More Helpers *)

let dummy_to_block (ignore : unit) = 
  { isdummy -> bit_to_region0 @ I secret,
    idx     -> int_to_region0 @ 0 secret,
    data    -> (rnd1 @ (), rnd1 @ ())
  }
in

(* Recursive Tree Operations *)

let rr_trivial (oram : trivial_oram) (idx : secret int 0) (read : to_block) : to_block =
  let rec rr_trivial_h (i : public int) (read : to_block) : to_block =
    if i = length(oram) then
      read
    else
      let bl = oram[i] <- dummy_to_block @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_bl) && idx_bl = idx in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, data -> (data_left_b, data_right_b) } in
      let _ = oram[i] <- b in
      rr_trivial_h @ (i + 1 public) @ a
  in
  rr_trivial_h @ 0 public @ read
in

let add_trivial (oram : trivial_oram) (read : to_block) =
  let rec add_trivial_h (i : public int) (read : to_block) : unit =
    if i = length(oram) then
      ()
    else
      let bl = oram[i] <- dummy_to_block @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, data -> data_bl } = bl in
      let (data_bl_left, data_bl_right) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, data -> data_r } = read in
      let (data_r_left, data_r_right) = data_r in
      let toswap = !(isdummy_r) && isdummy_bl in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (data_left_a, data_left_b) = mux linear (toswap, data_bl_left, data_r_left) in
      let (data_right_a, data_right_b) = mux universal (toswap, data_bl_right, data_r_right) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, data -> (data_left_a, data_right_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, data -> (data_left_b, data_right_b) } in
      let _ = oram[i] <- b in
      add_trivial_h @ (i + 1 public) @ a
  in
  add_trivial_h @ 0 public @ read
in

let rec tree_rr_rec01 (oram : oram) (idx : secret int) (level : public int) : data1 =
  let (norams, tr_oram) = oram in
  let levels = length(norams) in
  if level = levels then (* TODO: Should be >= *)
    let { isdummy -> ignore, idx -> ignore, data -> ret } = rr_trivial @ tr_oram @ idx @ (dummy_to_block @ ()) in
    ret
  else
    let (r0, r1) = tree_rr_rec10 @ oram @ idx @ level in (* TODO: idx should be idx / 2 *)
    let (r0_new, tag) = mux linear (idx = 0 secret, rnd0 @ (), r0) in
    let (r1_new, tag) = mux linear (idx = 1 secret, tag, r1) in
    let _ = tree_add_rec10 @ oram @ idx @ (level + 1 public) @ (r0_new, r1_new) in (* TODO: idx should be idx / 2 *)
    let (noram, ignore) = norams[level] in
    rr01 @ noram @ idx @ reveal(tag)

and tree_rr_rec10 (oram : oram) (idx : secret int) (level : public int) : data0 =
  let (norams, tr_oram) = oram in
  let (r0, r1) = tree_rr_rec01 @ oram @ idx @ (level + 1 public) in (* TODO: idx should be idx / 2 *)
  let (r0_new, tag) = mux linear (idx = 0 secret, rnd1 @ (), r0) in
  let (r1_new, tag) = mux linear (idx = 1 secret, tag, r1) in
  let _ = tree_add_rec01 @ oram @ idx @ (level + 1 public) @ (r0_new, r1_new) in (* TODO: idx should be idx / 2 *)
  let (ignore, noram) = norams[level] in
  rr10 @ noram @ idx @ reveal(tag)

and tree_add_rec01 (oram : oram) (idx : secret int) (level : public int) (data : data1) : unit =
  let (norams, tr_oram) = oram in
  ()

and tree_add_rec10 (oram : oram) (idx : secret int) (level : public int) (data : data0) : unit =
  let (norams, tr_oram) = oram in
  ()

in

()
