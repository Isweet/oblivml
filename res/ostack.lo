let trivial_init (size : public int) (default_value : unit -> secret int) =
  let default_bucket (ignore : unit) = (default_value @ (), -1 secret) in
  (default_bucket, array(size)[fun ignore -> default_bucket @ ()])
in

let trivial_read_and_remove (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : secret int =
    if curr_idx = len then
      let (ret, ignore) = acc_bucket in ret
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (addr = curr_addr, curr_data, acc_data) in
      let (t_addr, f_addr) = mux universal (addr = curr_addr, curr_addr, acc_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- false_bucket in
      iterate @ (curr_idx + 1 public) @ true_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let trivial_add (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) (data : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : unit =
    if curr_idx = len then
      ()
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (data, addr)
in

let trivial_pop (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : (secret int * secret int) =
    if curr_idx = len then
      acc_bucket
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let dummy_init (size : public int) (default_value : unit -> secret int) =
  trivial_init @ size @ default_value
in

let dummy_read_and_remove (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (pos : (public bit) vector) (addr : secret int) =
  trivial_read_and_remove @ oram @ addr
in

let dummy_add (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (pos : (secret bit 0) vector) (addr : secret int) (data : secret int) =
  trivial_add @ oram @ addr @ data
in

let log_2 (n : public int) =
  20 public
in

let make_pos_tag (size : public int) =
  array(size)[fun ignore -> toss secret 0]
in

let dummy_pos_tag (size : public int) =
  vector(size)[fun ignore -> O secret]
in

let use_pos_tag (tag : (secret flip 0) array) =
  let len = length(tag) in
  vector(len)[fun i -> let ele = tag[i] <- toss secret 0 in use(ele)]
in

let reveal_pos_tag (tag : (secret flip 0) array) =
  let len = length(tag) in
  vector(len)[fun i -> let ele = tag[i] <- toss secret 0 in reveal(ele)]
in

let default_value (ignore : unit) =
  0 secret
in

let makestack (size : public int) =
  { root_idx -> array(1 public)[fun ignore -> (1 secret)],
    root_pos -> array(1 public)[fun ignore -> make_pos_tag @ (log_2 @ size)],
    oram     -> dummy_init @ size @ default_value
  }
in

let stackop (s : { oram     : (unit -> (secret int * secret int)) * ((secret int * secret int) array),
                   root_idx : (secret int) array,
                   root_pos : ((secret flip 0) array) array })
            (ispush : secret bit)
            (d : secret int) =
  let { root_idx -> root_idx, root_pos -> root_pos, oram -> oram } = s in
  let (default_value, mem) = oram in
  let lgn = (20 public) in
  let dummy_pos = dummy_pos_tag @ lgn in
  let id = root_idx[0 public] in
  let pos0 = make_pos_tag @ lgn in
  let spos0 = use_pos_tag @ pos0 in
  let pos = root_pos[0 public] <- pos0 in
  let top = dummy_read_and_remove @ oram @ (reveal_pos_tag @ pos) @ id in
  let (p, ignore) = mux universal (ispush, spos0, dummy_pos) in
  let (i, ignore) = mux universal (ispush, id, 0 secret) in
  let (v, ignore) = mux universal (ispush, top, let (d, ignore) = default_value @ () in d) in
  let _ = dummy_add @ oram @ p @ i @ v in
  let n_pos = make_pos_tag @ lgn in
  let sn_pos = use_pos_tag @ n_pos in
  let n_id = id + 1 secret in
  ()
in

makestack @ 20 public
