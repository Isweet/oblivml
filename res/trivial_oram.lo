let init (size : public int) (default_value : unit -> secret int) =
  let default_bucket (ignore : unit) = (default_value @ (), -1 secret) in
  (default_bucket, array(size)[fun ignore -> default_bucket @ ()])
in

let read_and_remove (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : secret int =
    if curr_idx = len then
      let (ret, ignore) = acc_bucket in ret
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (addr = curr_addr, curr_data, acc_data) in
      let (t_addr, f_addr) = mux universal (addr = curr_addr, curr_addr, acc_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- false_bucket in
      iterate @ (curr_idx + 1 public) @ true_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let add (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) (data : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : unit =
    if curr_idx = len then
      ()
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (data, addr)
in

let pop (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : (secret int * secret int) =
    if curr_idx = len then
      acc_bucket
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let dfval (ignore : unit) =
  0 secret
in

let x = init @ 100 public @ dfval in
let _ = add @ x @ 1 secret @ 1 secret in
let _ = add @ x @ 2 secret @ 2 secret in
let a = read_and_remove @ x @ 1 secret in
let (k, b) = pop @ x in
let c = read_and_remove @ x @ 2 secret in
let _ = add @ x @ 3 secret @ 3 secret in
let d = read_and_remove @ x @ 1 secret in
let e = read_and_remove @ x @ 3 secret in


()
