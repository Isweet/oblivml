(* Types *)
type data = secret flip 0 * secret int in

type block =
  { isdummy : secret bit, 
    idx     : secret int, 
    pos     : secret bit,
    data    : data
  }
in

type bucket = block array in

type tree = public int * bucket array in

type trivial_oram = public int * bucket in

type nr_oram = public int * tree in

type oram = nr_oram * trivial_oram in

(* Helpers *)
let rnd (ignore : unit) = toss secret 0 in

let b2i (b : public bit) =
  if b then 0 public else 1 public
in

let rec pow2 (exp : public int) : public int =
  if exp = 0 public then
    1 public
  else
    2 public * pow2 @ (exp + -1 public)
in

let dummy_block (ignore : unit) = 
  { isdummy -> I secret,
    idx     -> 0 secret,
    pos     -> O secret,
    data    -> (rnd @ (), 0 secret)
  }
in

(* Trivial ORAM *)

let trivial_read_and_remove (oram : trivial_oram) (idx : secret int) =
  let (cap, mem) = oram in
  let r = dummy_block @ () in
  let rec iterate (i : public int) (r : block) : block =
    if i = cap then
      r
    else
      let bl = mem[i] <- dummy_block @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_tag, data_bl_val) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = r in
      let (data_r_tag, data_r_val) = data_r in
      let toswap = isdummy_r && !(isdummy_bl) in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_tag_a, data_tag_b) = mux linear (toswap, data_bl_tag, data_r_tag) in
      let (data_val_a, data_val_b) = mux universal (toswap, data_bl_val, data_r_val) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_tag_a, data_val_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_tag_b, data_val_b) } in
      let _ = mem[i] <- a in
      iterate @ (i + 1 public) @ b
  in
  let { isdummy -> ignore, idx -> ignore, pos -> ignore, data -> ret } = iterate @ 0 public @ r in
  ret
in

let trivial_add (oram : trivial_oram) (idx : secret int) (tag : secret bit) (data : data) =
  dummy_block @ () (* TODO: Should be easy *)
in 

(* NR ORAM *)

let nr_read_and_remove (oram : nr_oram) (idx  : secret int) (tag  : public bit) =
  let (cap, tree) = oram in
  let (bucket_size, a) = tree in
  let r = dummy_block @ () in
  let rec read_sub (offset : public int) (tag : public bit) (r : block) : block =
    let total_offset = offset + -1 public + (b2i @ tag) in
    if total_offset = cap then (* TODO: should be >= *)
      r
    else
      let bucket = a[total_offset] in
      let rec read_bucket (i : public int) (r : block) : block =
        if i = bucket_size then (* TODO: should be >= *)
          r
        else
          let bl = bucket[i] <- dummy_block @ () in
          let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
          let (data_bl_tag, data_bl_val) = data_bl in
          let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = r in
          let (data_r_tag, data_r_val) = data_r in
          let toswap = !(isdummy_bl) && (idx_bl = idx) in
          let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
          let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
          let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
          let (data_tag_a, data_tag_b) = mux linear (toswap, data_bl_tag, data_r_tag) in
          let (data_val_a, data_val_b) = mux universal (toswap, data_bl_val, data_r_val) in
          let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_tag_a, data_val_a) } in
          let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_tag_b, data_val_b) } in
          let _ = bucket[i] <- b in
          read_bucket @ (i + 1 public) @ a
      in
      let r = read_bucket @ 0 public @ r in
      read_sub @ (offset * 2 public) @ tag @ r
  in
  let { isdummy -> ignore, idx -> ignore, pos -> ignore, data -> data } = read_sub @ 1 public @ tag @ (dummy_block @ ()) in
  data
in

let nr_add (oram : nr_oram) (idx : secret int) (tag : secret bit) (data : data) =
  let (cap, tree) = oram in
  let (bucket_size, a) = tree in
  let root_bucket = a[0 public] in
  let rec add_bucket (i : public int) (r : block) : unit =
    if i = bucket_size then (* TODO: should be >= *)
      ()
    else
      let bl = root_bucket[i] <- dummy_block @ () in
      let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
      let (data_bl_tag, data_bl_val) = data_bl in
      let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = r in
      let (data_r_tag, data_r_val) = data_r in
      let toswap = !(isdummy_r) && isdummy_bl in
      let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
      let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
      let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
      let (data_tag_a, data_tag_b) = mux linear (toswap, data_bl_tag, data_r_tag) in
      let (data_val_a, data_val_b) = mux universal (toswap, data_bl_val, data_r_val) in
      let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_tag_a, data_val_a) } in
      let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_tag_b, data_val_b) } in
      let _ = root_bucket[i] <- b in
      add_bucket @ (i + 1 public) @ a
  in
  let _ = add_bucket @ 0 public @ { isdummy -> O secret, idx -> idx, pos -> tag, data -> data } in
  let _ = a[0 public] <- root_bucket in
  ()
in


let nr_eviction (oram : nr_oram) =
  let (cap, tree) = oram in
  let (bucket_size, a) = tree in
  let do_eviction (idx : public int) (level : public int) =
    let bucket = a[idx] in
    let rec readout (i : public int) (r : block) : block =
      if i = bucket_size then
        r
      else
        let bl = bucket[i] <- dummy_block @ () in
        let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
        let (data_bl_tag, data_bl_val) = data_bl in
        let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = r in
        let (data_r_tag, data_r_val) = data_r in
        let toswap = !(isdummy_bl) && isdummy_r in
        let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
        let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
        let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
        let (data_tag_a, data_tag_b) = mux linear (toswap, data_bl_tag, data_r_tag) in
        let (data_val_a, data_val_b) = mux universal (toswap, data_bl_val, data_r_val) in
        let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_tag_a, data_val_a) } in
        let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_tag_b, data_val_b) } in
        let _ = bucket[i] <- b in
        readout @ (i + 1 public) @ a
    in
    let rec putin (i : public int) (r : block) (pos_matched : secret bit) (blocks : bucket) : block =
      if i = bucket_size then
        r
      else
        let bl = blocks[i] <- dummy_block @ () in
        let { isdummy -> isdummy_bl, idx -> idx_bl, pos -> pos_bl, data -> data_bl } = bl in
        let (data_bl_tag, data_bl_val) = data_bl in
        let { isdummy -> isdummy_r, idx -> idx_r, pos -> pos_r, data -> data_r } = r in
        let (data_r_tag, data_r_val) = data_r in
        let toswap = isdummy_bl && !(isdummy_r) && pos_matched in
        let (isdummy_a, isdummy_b) = mux universal (toswap, isdummy_bl, isdummy_r) in
        let (idx_a, idx_b) = mux universal (toswap, idx_bl, idx_r) in
        let (pos_a, pos_b) = mux universal (toswap, pos_bl, pos_r) in
        let (data_tag_a, data_tag_b) = mux linear (toswap, data_bl_tag, data_r_tag) in
        let (data_val_a, data_val_b) = mux universal (toswap, data_bl_val, data_r_val) in
        let a = { isdummy -> isdummy_a, idx -> idx_a, pos -> pos_a, data -> (data_tag_a, data_val_a) } in
        let b = { isdummy -> isdummy_b, idx -> idx_b, pos -> pos_b, data -> (data_tag_b, data_val_b) } in
        let _ = blocks[i] <- b in
        putin @ (i + 1 public) @ a @ pos_matched @ blocks
    in
    let { isdummy -> isdummy_ro, idx -> idx_ro, pos -> pos_ro, data -> data_ro } = readout @ 0 public @ (dummy_block @ ()) in
    let pos_matched_left = pos_ro in (* TODO *)
    let pos_matched_right = pos_ro in (* TODO *)
    let ro = { isdummy -> isdummy_ro, idx -> idx_ro, pos -> pos_ro, data -> data_ro } in
    let ro = putin @ 0 public @ ro @ pos_matched_left @ a[2 public * idx + (1 public)] in
    let ro = putin @ 0 public @ ro @ pos_matched_left @ a[2 public * idx + (2 public)] in
    ()
  in
  let rec rec_evict (level : public int) : unit =
    let pow2l = pow2 @ level in
    if pow2l = cap then
      ()
    else
      let todo = 0 public in (* TODO *)
      let _ = do_eviction @ todo @ (level + 1 public) in
      let _ = do_eviction @ todo @ (level + 1 public) in
      rec_evict @ (level + 1 public)
  in
  rec_evict @ 0 public
in

let read (oram : oram) (idx : secret int) =
  () (* What do I do here? *)
in

let write (oram : oram) (idx : secret int) (data : data) =
  () (* What do I do here? *)
in

()
