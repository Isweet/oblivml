type block = exists r1, r2 . r1 _||_ r2 & { isdummy : bit@(secret, r1),
                                            idx     : int@(secret, r1),
                                            pos     : int@(secret, r1),
                                            data    : int@(secret, r1) * flip@(r2)
                                          } in
type bucket = block array in
type noram = bucket array in
type ostack = exists r1, r2 . r1 _||_ r2 &
  { store : noram,
    idx_r : int@(secret, r1) array,
    pos_r : flip@(r2) array
  } in

let stackop (stk : ostack) (ispush : bit@(secret, _|_)) (data : int@(secret, _|_)) =
  let < r1, r2 . stk'> = stk in
  let { store -> store_stk, idx_r -> idx_r_stk, pos_r -> pos_r_stk } = stk' in

  let idx_stk = idx_r_stk[0 public] in
  let < r_fresh1 . fresh> = toss in
  let pos_stk = pos_r_stk[0 public] <- fresh in




(*

  David's suggestion:

  - toss ->

    new_region r1
    flip r1



  let idx_left = -1 secret in
  let idx_right = idx_stk in

  let 

  let <r_pos_left . pos_left> = toss in
  let pos_right = pos_stk in

  let (data_new_left, ignore) = rr @ store_stk @ idx_left @ reveal(pos_left) in
  let <r_pos_new_left . pos_new_left> = toss in
  let (data_new_right, pos_new_right) = rr @ store_stk @ idx_left @ reveal(pos_right) in

  let (data_new, ignore) = mux universal (ispush, data_new_left, data_new_right) in
  let (pos_new, ignore) = mux affine (ispush, pos_new_left, pos_new_right) in

  let b_pos_left = pos_stk in
  let <r_b_pos_right . b_pos_right> = toss in

  let b_pos = mux affine (ispush, b_pos_left, b_pos_right) in

  let b = (data, b_pos) in

*)
  ()
in
()