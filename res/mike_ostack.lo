let trivial_init (size : public int) (default_value : unit -> secret int) =
  let default_bucket (ignore : unit) = (default_value @ (), -1 secret) in
  (default_bucket, array(size)[fun ignore -> default_bucket @ ()])
in

let trivial_read_and_remove (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : secret int =
    if curr_idx = len then
      let (ret, ignore) = acc_bucket in ret
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (addr = curr_addr, curr_data, acc_data) in
      let (t_addr, f_addr) = mux universal (addr = curr_addr, curr_addr, acc_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- false_bucket in
      iterate @ (curr_idx + 1 public) @ true_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let trivial_add (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (addr : secret int) (data : secret int) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : unit =
    if curr_idx = len then
      ()
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (curr_addr = -1 secret && !(acc_addr = -1 secret), acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (data, addr)
in

let trivial_pop (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) =
  let (default_bucket, mem) = oram in
  let len = length(mem) in
  let rec iterate (curr_idx : public int) (acc_bucket : (secret int * secret int)) : (secret int * secret int) =
    if curr_idx = len then
      acc_bucket
    else
      let (curr_data, curr_addr) = mem[curr_idx] <- default_bucket @ () in
      let (acc_data, acc_addr) = acc_bucket in
      let (t_data, f_data) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_data, curr_data) in
      let (t_addr, f_addr) = mux universal (!(curr_addr = -1 secret) && acc_addr = -1 secret, acc_addr, curr_addr) in
      let (true_bucket, false_bucket) = ((t_data, t_addr), (f_data, f_addr)) in
      let _ = mem[curr_idx] <- true_bucket in
      iterate @ (curr_idx + 1 public) @ false_bucket
  in
  iterate @ 0 public @ (default_bucket @ ())
in

let dummy_init (size : public int) (default_value : unit -> secret int) =
  trivial_init @ size @ default_value
in

let dummy_read_and_remove (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (pos : public bit) (addr : secret int) =
  trivial_read_and_remove @ oram @ addr
in

let dummy_add (oram : (unit -> (secret int * secret int)) * ((secret int * secret int) array)) (pos : secret bit 0) (addr : secret int) (data : secret int) =
  trivial_add @ oram @ addr @ data
in

let log_2 (n : public int) =
  20 public
in

let make_pos_tag (size : public int) = toss secret 0 
in

let dummy_pos_tag (size : public int) = 0 secret
in

let use_pos_tag (tag : secret flip 0) = use(tag)
in

let reveal_pos_tag (tag : secret flip 0) = reveal(tag)
in

let default_value (ignore : unit) = 0 secret
in

let makestack (size : public int) =
  { root_idx -> 1 secret,
    root_pos -> make_pos_tag @ (log_2 @ size),
    oram     -> dummy_init @ size @ default_value
  }
in

let fakedata (d : secret int) : (secret int * secret flip 0) =
  (d, toss secret 0)
in
  
let unfakedata (b : (secret int * secret flip 0)) = 
  let (d,ignore) = b in d
in

let stackop (s : { oram     : (unit -> (secret int * secret int)) * ((secret int * secret int) array),
                   root_idx : secret int,
                   root_pos : secret flip 0 })
            (ispush : secret bit)
            (d : secret int) =
  let { root_idx -> root_idx, root_pos -> root_pos, oram -> oram } = s in
  let (default_value, mem) = oram in
  let lgn = (20 public) in
  let (read_idx, ignore) = mux universal (ispush, -1 secret, root_idx) in
  let pos0 = make_pos_tag @ lgn in
  let (read_pos, b_pos) = mux universal (ispush, pos0, root_pos) in
  let data0 = dummy_read_and_remove @ oram @ (reveal_pos_tag @ read_pos) @ read_idx in
  let (data,pos0) = fakedata @ data0 in (* since we really want to store a pair in the ORAM *)
  let b = (d, b_pos) in
  let (aid, ignore) = mux universal (ispush, root_idx + 1 secret, -1 secret) in
  let apos = make_pos_tag @ lgn in
  let d0 = unfakedata @ b in (* can't store the pair ... *)
  let ignore = dummy_add @ oram @ use(apos) @ aid @ d0 in (* should be use_tag *)
  let (new_root_idx,ignore) = mux universal (ispush, root_idx + 1 secret, root_idx + -1 secret) in
  let (new_root_pos,ignore) = mux linear (ispush, apos, pos0) in
  ({ root_idx -> new_root_idx, root_pos -> new_root_pos, oram -> oram}, data)
in

let s = makestack @ 20 public in
stackop @ s @ I secret @ 23 secret
