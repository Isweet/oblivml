(** Non-Recursive ORAM *)

(***********************
 ** Utility Functions **
 ***********************)

let rec div_2 (n : int) : int =
  if n = 0 then
    0
  else
    div_2 (n - 2) + 1
in

let rec log_2 (n : int) : int =
  if n = 1 then
    0
  else
    log_2 (div_2 n) + 1
in

let rec pow_2 (n : int) : int =
  if n = 0 then
    1
  else
    2 * (pow_2 (n - 1))
in

(***********************
 ** Type Declarations **
 ***********************)

(** Data user is storing *)
type user_data = rint<`r0 \/ `r1> * rint<`r0 \/ `r1>
in

(** Data the NRORAM is storing *)
type nr_data =
  { is_some : bool<`r0>
  ; nr_tag  : int<`r0>
  ; nr_val  : user_data
  }
in

(** Blocks in the trivial ORAM *)
type block =
  { is_some : bool<`r0>
  ; idx     : int<`r0>
  ; data    : nr_data
  }
in

type trivial_oram = block array
in

type nr_oram = trivial_oram array
in

type oram = nr_oram array * trivial_oram
in

(********************
 ** Default Values **
 ********************)

let default_user_data _ =
  (rnd<`r0 \/ `r1>, rnd<`r0 \/ `r1>)
in

let default_nr_data _ =
  { is_some = false
  ; nr_tag  = 0
  ; nr_val  = default_user_data ()
  }
in

let default_block _ =
  { is_some = false
  ; idx     = 0
  ; data    = default_nr_data ()
  }
in

(******************
 ** Trivial ORAM **
 ******************)

let trivial_init (size : int) =
  array(size)[fun (_ : int) . default_block ()]
in

let trivial_rr' (toram : trivial_oram) (idx : int<secret>) =
  let len = length(toram) in
  let rec iterate (i : int) (acc : block) : block =
    if i = len then
      acc
    else
      let curr = toram[i] <- default_block in
      let swap = not acc.is_some && idx = curr.idx in
      let (l, r) = mux(swap, curr, acc) in
      let _ = toram[i] <- r in
      iterate (i + 1) l
  in
  iterate 0 default_block
in

let trivial_rr (toram : trivial_oram) (idx : int<secret>) =
  let result = trivial_rr' toram idx in
  result.data
in

let trivial_add' (toram : trivial_oram) (blk : block) =
  let len = length(toram) in
  let rec iterate (i : int) (acc : block) : unit =
    if i = len then
      ()
    else
      let curr = toram[i] <- default_block in
      let swap = not curr.is_some in
      let (l, r) = mux(swap, curr, acc) in
      let _ = toram[i] <- r in
      iterate (i + 1) l
  in
  iterate 0 blk
in

let trivial_add (toram : trivial_oram) (idx : int<`r0>) (data : nr_data) =
  trivial_add' toram { is_some = true
                     ; idx     = idx
                     ; data    = data
                     }
in

let trivial_pop' (toram : trivial_oram) =
  let len = length(toram) in
  let rec iterate (i : int) (acc : block) : block =
    if i = len then
      acc
    else
      let curr = toram[i] <- default_block in
      let swap = not acc.is_some && curr.is_some in
      let (l, r) = mux(swap, curr, acc) in
      let _ = toram[i] <- r in
      iterate (i + 1) l
  in
  iterate 0 default_block
in


(************************
 ** NON-RECURSIVE ORAM **
 ************************)

(** ASSUMPTION:
      Size of the NR ORAM is exactly 2^k - 1, k >= 2.

      This ensures that the tree is full and has at least depth 2. *)

let nr_init (size : int) (bucket_size : int) =
  array(size)[fun (_ : int) . trivial_init bucket_size]
in

let nr_rr' (nroram : nr_oram) (idx : int<secret>) (tag : int) =
  let len = length(nroram) in
  let depth = log_2 (len + 1) in
  let rec iterate (level : int) (acc : nr_data) : nr_data =
    if level = depth then
      acc
    else
      let base = (pow_2 level) - 1 in
      let bucket_loc = base + (tag & base) in
      let bucket = nroram[bucket_loc] in
      let res = trivial_rr bucket idx in

      let pass = res.is_some in
      let (ret, _) = mux(pass, res, acc) in
      iterate (level + 1) ret
  in
  iterate 0 default_nr_data
in

let nr_rr (nroram : nr_oram) (idx : int<secret>) (tag : int) =
  let ret = nr_rr' nroram idx tag in
  ret.nr_val
in

let nr_evict' (nroram : nr_oram) (level : int) (loc : int) =
  let mask = pow_2 level in

  let bucket = nroram[loc] in
  let popped = trivial_pop' bucket in

  let left = (popped.data.nr_tag & mask) = 0 in
  (* Basically need to claim that this mux is OK *)
  let (l, r) = mux(left, popped, default_block) in

  let left_child  = nroram[(2 * loc) + 1] in
  let right_child = nroram[(2 * loc) + 2] in

  let _ = trivial_add' left_child l in
  trivial_add' right_child r
in

let nr_evict (nroram : nr_oram) =
  let len = length(nroram) in
  let depth = log_2 (len + 1) in
  let rec iterate (level : int) : unit =
    if level = depth - 1 then
      ()
    else
      let mask = pow_2 level in
      let base = (pow_2 level) - 1 in

      (* Two evictions per-level *)
      let r1 = rnd<`r1> in
      let loc1 = base + (reveal(r1) & base) in
      let _ = nr_evict' nroram level loc1 in

      let r2 = rnd<`r1> in
      let loc2 = base + (reveal(r2) & base) in
      let _ = nr_evict' nroram level loc2 in

      iterate (level + 1)
  in
  iterate 0
in

let nr_add' (nroram : nr_oram) (blk : block) =
  let bucket = nroram[0] in
  let _ = trivial_add' bucket blk in
  nr_evict nroram
in

let nr_add (nroram : nr_oram) (idx : int<`r0>) (tag : int<`r0>) (data : user_data) =
  nr_add' nroram { is_some = true
                 ; idx     = idx
                 ; data    = { is_some = true
                             ; nr_tag  = tag
                             ; nr_val  = data
                             }
                 }
in

(************************
 ** RECURSIVE ORAM **
 ************************)

let tree_add_h (oram : oram) (idx : int<secret>) (level : int) (d : rint<`r0 \/ `r1> * rint<`r0 \/ `r1>) =
  ()
in

let rec tree_rr_h (oram : oram) (idx : int<secret>) (level : int) : rint<`r0 \/ `r1> * rint<`r0 \/ `r1> =
  let (norams, troram) = oram in
  let levels = length(norams) in
  if level = levels then
    let result = trivial_rr troram idx in
    result.nr_val
  else
    let (r0, r1) = tree_rr_h oram (idx / 2) (level + 1) in
    let zero_m2 = idx % 2 = 0 in
    let one_m2  = idx % 2 = 1 in
    let fresh = rnd<`r0 \/ `r1> in
    let (r0', tag) = mux(zero_m2, fresh, r0) in
    let (r1', tag) = mux(one_m2, tag, r1) in
    let d' = (r0', r1') in
    let _ = tree_add_h oram (idx / 2) (level + 1) d' in
    let curr_noram = norams[level] in
    nr_rr curr_noram idx reveal(tag)
in

let tree_rr (oram : oram) (idx : int<secret>) =
  tree_rr_h oram idx 0
in

let rec add_rr_h (oram : oram) (idx : int<secret>) (level : int) (d : rint<`r0 \/ `r1> * rint<`r0 \/ `r1>) : unit =
  let (norams, troram) = oram in
  let levels = length(norams) in
  if level = levels then
    let tag = rnd<`r0> in
    let tag = use(tag) in
    (* The use of + 0<secret, `r0> is to raise the region of idx from _|_ to `r0 *)
    (* I've removed it now, but now to typecheck this we will need region subtyping for ints *)
    trivial_add troram idx { is_some = true
                           ; nr_tag  = tag
                           ; nr_val  = d
                           }
  else
    let (r0, r1) = tree_rr_h oram (idx / 2) (level + 1) in
    let zero_m2 = idx % 2 = 0 in
    let one_m2  = idx % 2 = 1 in
    let fresh = rnd<`r0 \/ `r1> in
    let sec_fresh = use(fresh) in
    let (r0', tag) = mux(zero_m2, fresh, r0) in
    let (r1', tag) = mux(one_m2, tag, r1) in
    let d' = (r0', r1') in
    let _ = tree_add_h oram (idx / 2) (level + 1) d' in
    let curr_noram = norams[level] in
    (* Uncomment the line below to see the type error mentioned in section 5.2 of the paper *)
    (* Again, need region subtyping for `idx` *)
(*  let _ = nr_add curr_noram idx sec_fresh d in *)
    ()
in

let add_rr (oram : oram) (idx : int<secret>) (d : rint<`r0 \/ `r1> * rint<`r0 \/ `r1>) =
  add_rr_h oram idx 0 d
in

()