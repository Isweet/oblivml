(** Oblivious Stacks *)

(***********************
 ** Type Declarations **
 ***********************)

type block =
  Π meta_max : region .
  Π ptr_min  : { meta_max < _ } .
  Σ meta     : { _ <= meta_max } . (* Maybe don't even need existentials? Just need "bounds"?
  Σ ptr      : { ptr_min <= _ } .
  { is_some  : bool<meta>
  ; idx      : int<meta>
  ; tag      : int<meta>
  ; next     : rint<ptr>
  ; data     : int<meta>
  }

type trivial_oram =
  Π meta_max : region .
  Π ptr_min  : { meta_max < _ } .
  (block meta_max ptr_min) array

type nr_oram =
  Π meta_max : region .
  Π ptr_min  : { meta_max < _ } .
  (trivial_oram meta_max ptr_min) array

type ostack =
  Σ meta_max : region .
  Σ ptr_min  : { meta_max < _ } .
  { oram  : nr_oram meta_max ptr_min
  ; idx_r : int<meta_max>
  ; tag_r : rint<ptr_min>
  }

let default_block (Π meta_max : region) (Π ptr_min  : { meta_max < _ }) () : block meta_max ptr_min =
  let term =
    { is_some = false<⊥>
    ; idx     = -1<⊥>
    ; tag     = -1<⊥>
    ; next    = rnd<secret, ptr_min>
    ; data    = 0<secret, ⊥>
    }
  in
  ⌊ ⊥ , ⌊ ptr_min , term ⌋ ⌋ (* OK since ⊥ <= any meta_max chosen, and ⊥ < ptr_min (since ptr_min must be non-bottom from being > meta_max *)

(* Need to know that when I rr on `trivial_oram meta_max ptr_min` with maximum index, it becomes `trivial_oram (meta_max - 1) (ptr_min - 1)` *)
(* Is there a name for a dependent collection that tracks its maximum? *)
let trivial_rr' (Π meta_max : int) (Π ptr_min  : { meta_max < _ }) (troram : trivial_oram meta_max ptr_min) (idx : int<secret>) =
  let len = length(toram) in
  let rec iterate (i : int<public>) (acc : block meta_max ptr_min) : block meta_max ptr_min =
    if i = len then
      acc
    else
      let curr = toram[i] <- default_block meta_max ptr_min () in
      let ⌊ meta_curr , ⌊ ptr_curr , curr ⌋ ⌋ = curr in   (* meta_curr <= meta_max, ptr_min <= ptr_curr *)
      let ⌊ meta_acc , ⌊ ptr_acc , acc ⌋ ⌋ = acc in       (* meta_acc <= meta_max, ptr_min <= ptr_acc *)
      let swap = not acc.is_some && idx = curr.idx in     (* Need: meta_curr ⊔ meta_acc < ptr_curr and meta_curr ⊔ meta_acc < ptr_acc *)
      let (l, r) = mux(swap, curr, acc) in                (* Pf: Since meta_curr <= meta_max and meta_acc <= meta_max we have meta_curr ⊔ meta_acc <= meta_max < ptr_min <= ptr_curr (ptr_acc) *)
      let _ = toram[i] <- ⌊ meta_curr ⊔ meta_acc , ⌊ ptr_curr ⊔ ptr_acc , r ⌋ ⌋ (* Could assign these in a path-sensitive manner if necessary? Maybe? Won't worry about it for now. *)
      iterate (i + 1<public, _|_>) ⌊ meta_curr ⊔ meta_acc , ⌊ ptr_curr ⊔ ptr_acc , l ⌋ ⌋
  in
  iterate 0<public, _|_> (default_block ()<public, _|_>)
in


let nr_rr' (nroram : nr_oram) (idx : int<secret, _|_>) (tag : int<public, _|_>) =
  let len = length(nroram) in
  let depth = log_2 (len + 1<public, _|_>) in
  let rec iterate (level : int<public, _|_>) (acc : nr_data) : nr_data =
    if level = depth then
      acc
    else
      let base = (pow_2 level) - 1<public, _|_> in
      let bucket_loc = base + (tag & base) in
      let bucket = nroram[bucket_loc] in
      let res = trivial_rr bucket idx in

      let pass = res.is_some in
      let (ret, _) = mux(pass, res, acc) in
      iterate (level + 1<public, _|_>) ret
  in
  iterate 0<public, _|_> (default_nr_data ()<public, _|_>)
in

let nr_rr (nroram : nr_oram) (idx : int<secret, _|_>) (tag : int<public, _|_>) =
  let ret = nr_rr' nroram idx tag in
  ret.nr_val
in

let nr_evict' (nroram : nr_oram) (level : int<public, _|_>) (loc : int<public, _|_>) =
  let mask = pow_2 level in

  let bucket = nroram[loc] in
  let popped = trivial_pop' bucket in
  let default = default_block ()<public, _|_> in

  let popped_nu = { is_some = popped.is_some
                  ; idx     = popped.idx
                  ; data    = { is_some = popped.data.is_some
                              ; nr_tag  = popped.data.nr_tag
                              ; nr_val  = { is_some    = popped.data.nr_val.is_some
                                          ; ostack_tag = popped.data.nr_val.ostack_tag
                                          ; ostack_val = popped.data.nr_val.ostack_val
                                          }
                              }
                  } in

  let default_nu = { is_some = default.is_some
                   ; idx     = default.idx
                   ; data    = { is_some = default.data.is_some
                               ; nr_tag  = default.data.nr_tag
                               ; nr_val  = { is_some    = default.data.nr_val.is_some
                                           ; ostack_tag = default.data.nr_val.ostack_tag
                                           ; ostack_val = default.data.nr_val.ostack_val
                                           }
                               }
                   } in

  let left = (popped.data.nr_tag & mask) = 0<secret, `r0> in

  (* Basically need to claim that this mux is OK *)
  let (l_nu, r_nu) = mux(left, popped_nu, default_nu) in

  let l = { is_some = l_nu.is_some
          ; idx     = l_nu.idx
          ; data    = { is_some = l_nu.data.is_some
                      ; nr_tag  = l_nu.data.nr_tag
                      ; nr_val  = { is_some    = l_nu.data.nr_val.is_some
                                  ; ostack_tag = l_nu.data.nr_val.ostack_tag
                                  ; ostack_val = l_nu.data.nr_val.ostack_val
                                  }
                      }
          } in

  let r = { is_some = r_nu.is_some
          ; idx     = r_nu.idx
          ; data    = { is_some = r_nu.data.is_some
                      ; nr_tag  = r_nu.data.nr_tag
                      ; nr_val  = { is_some    = r_nu.data.nr_val.is_some
                                  ; ostack_tag = r_nu.data.nr_val.ostack_tag
                                  ; ostack_val = r_nu.data.nr_val.ostack_val
                                  }
                      }
          } in

  let left_child  = nroram[(2<public, _|_> * loc) + 1<public, _|_>] in
  let right_child = nroram[(2<public, _|_> * loc) + 2<public, _|_>] in

  let _ = trivial_add' left_child l in
  trivial_add' right_child r
in

let nr_evict (nroram : nr_oram) =
  let len = length(nroram) in
  let depth = log_2 (len + 1<public, _|_>) in
  let rec iterate (level : int<public, _|_>) : unit<public, _|_> =
    if level = depth - 1<public, _|_> then
      ()<public, _|_>
    else
      let mask = pow_2 level in
      let base = (pow_2 level) - 1<public, _|_> in

      (* Two evictions per-level *)
      let r1 = rnd<secret, `r0> in
      let loc1 = base + (reveal(r1) & base) in
      let _ = nr_evict' nroram level loc1 in

      let r2 = rnd<secret, `r0> in
      let loc2 = base + (reveal(r2) & base) in
      let _ = nr_evict' nroram level loc2 in

      iterate (level + 1<public, _|_>)
  in
  iterate 0<public, _|_>
in

let nr_add' (nroram : nr_oram) (blk : block) =
  let bucket = nroram[0<public, _|_>] in
  let _ = trivial_add' bucket blk in
  nr_evict nroram
in

let nr_add (nroram : nr_oram) (idx : int<secret, `r0>) (tag : int<secret, `r0>) (data : ostack_data) =
  nr_add' nroram { is_some = true<secret, `r0>
                 ; idx     = idx
                 ; data    = { is_some = true<secret, `r0>
                             ; nr_tag  = tag
                             ; nr_val  = data
                             }
                 }
in

(*************
 ** OSTACKS **
 *************)

let ostack_init (size : int<public, _|_>) (bucket_size : int<public, _|_>) =
  let term =
    { oram  = nr_init size bucket_size
    ; idx_r = array(1<public, _|_>)[fun (_ : int<public, _|_>) . 0<⊥>]
    ; tag_r = array(1<public, _|_>)[fun (_ : int<public, _|_>) . rnd<{ 0 }>]
    }
  in
  ⌊ ⊥ , ⌊ { 0 } , term ⌋ ⌋
in

let stackop (ostack : ostack) (ispush : bool<secret, _|_>) (data : user_data) =
  let ⌊ meta , ⌊ ptr , ostack ⌋ ⌋ = ostack in
  let nroram = ostack.oram in
  let idx = ostack.idx_r[0<public, _|_>] in
  let tag = ostack.tag_r[0<public, _|_>] <- rnd<secret, ptr> in

  let (rr_idx, _) = mux(ispush, -1<secret, _|_>, idx) in
  let (rr_tag, add_tag) = mux(ispush, rnd<secret, `r0>, tag) in
  let res = nr_rr nroram rr_idx reveal(rr_tag) in

  let (idx', _) = mux(ispush, idx + 1<secret, _|_>, idx - 1<secret, _|_>) in
  let fresh = rnd<secret, `r0> in
  let (tag', _) = mux(ispush, trust(fresh), res.ostack_tag) in
  let tag' = prove(tag') in

  let cand = { is_some = true<secret, _|_>
             ; idx     = idx'
             ; data    = { is_some = true<secret, _|_>
                         ; nr_tag  = use(tag')
                         ; nr_val  = { is_some    = true<secret, _|_>
                                     ; ostack_tag = trust(add_tag)
                                     ; ostack_val = data
                                     }
                         }
             } in

  let default = default_block ()<public, _|_> in

  let (add, _) = mux(ispush, cand, default) in

  let _ = nr_add' nroram add in

  let _ = ostack.idx_r[0<public, _|_>] <- idx' in
  let _ = ostack.tag_r[0<public, _|_>] <- tag' in

  res.ostack_val
in

()<public, _|_>
